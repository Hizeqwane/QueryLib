# Библиотека для работы с запросами

  Данная библиотека предназначена для упрощения проектирования подсистемы запросов.
Пакет предлагает следующие возможности:
- простые и удобные классы для описания допустимых фильтраций, сортировок и модификаций;
- обобщённый класс запроса с пагинацией, фильтрами, сортировками и модификациями;
- механизмы преобразования входящего запроса в формализованные структуры фильтров, сортировок и модификаций, которые можно применять на уровне _DbContext_'а.

В основе работы механизмов фильтрации и сортировки лежит паттерн "Спецификация": в запрос передаются специальные объекты-спецификации, которые содержат в себе логику запроса.

## Пагинация
  Запрос принимает два параметра: _Skip_ (сколько записей пропустить) и _Take_ (сколько записей забрать). В пакете предусмотрены методы-расширения для _IQueryable_, позволяющие передавать _Nullable<int>_ в соответствующие методы пагинации.
  По умолчанию на уровне объекта запроса есть ограничения:
  - _Skip_ - неотрицательное число;
  - _Take_ - целое число в диапазоне от 0 до 1000.

## Фильтрация
  Фильтры передаются в запрос в виде коллекции простых объектов с ключом и значением.
При передаче нескольких фильтров с одинаковым ключом такие фильтры объединяются по "ИЛИ". Далее все имеющиеся фильтры объединяются по "И". Такой подход не позволяет объединять по "ИЛИ" несколько разных фильтров, но чаще всего это не требуется, или комбинацию таких фильтров можно заменить одним.

## Сортировка
  Сортировки передаются в запрос в виде коллекции простых объектов с ключом и параметром направления сортировки по данному ключу.
  На уровне определения сортировки есть возможность определить простую сортировку по делегату получения свойства объекта или же выбрать более сложную логику путём задания нужной спецификации сортировки.
  При запросе объектов сортировки применяются в порядке их получения - сперва сортируем по первой спецификации, затем по второй и т.д.

## Модификации
  Модификации передаются в запрос в виде коллекции простых объектов с ключом модификации, которую требуется применить к ответу.
  Модификация описывается делегатом, который получает и отдаёт объект ответа. Все полученные модификации объединяются в цепочку делегатов и вызываются после получения данных.

## Пример
Есть массив объектов Person:
```
{ Id = 1, Name = "Первый" },
{ Id = 2, Name = "Второй" },
{ Id = 3, Name = "Третий" }
```

Мы пытаемся запросить объекты, чьё имя содержит 'ро' или 'пер' (поиск регистронезависимый) и отсортировать полученные данные по полю _Name_.
Для этого можно использовать подобный запрос:
```
{
  "skip": 0,
  "take": 2,
  "filters": [
    {
      "key": "name",
      "value": "ро"
    },
    {
      "key": "name",
      "value": "пер"
    }
  ],
  "sorts": [
    {
      "key": "name",
      "order": "Asc"
    }
  ],
  "modifiers": [
    {
      "key": "ToUpper"
    }
  ]
}
```

Результат запроса:
```
[
  {
    "name": "ВТОРОЙ",
    "id": 2
  },
  {
    "name": "ПЕРВЫЙ",
    "id": 1
  }
]
```

В репозитории представлен демо-проект, который можно запустить как приложение с _SwaggerUI_ (метод для получения списка в проекте требуется передачи фильтра по типу объекта, например, { "key": "type", "value": "person" }).
